import java_cup.runtime.Symbol;
import java.util.*;
import java.lang.*;
/* Preliminaries to use the scanner.  */
scan with {: 
	return lexer.next_token(); 
:};

action code {:
  public static int size = 0;
  public static Hashtable<String, Integer> labelTable 
  = new Hashtable<String, Integer>();
:}
parser code {: 

  ExprLex lexer;

  public ExprParser(ExprLex lex) {
      super(lex);
      lexer = lex;
  }
:}; 

/* Terminals (tokens returned by lexer). */
terminal CLASS, EXTENDS, PUBLIC, STATIC, VOID;
terminal STRING, NEW, RETURN, INT_TYPE;
terminal BOOLEAN_TYPE, IF, ELSE, WHILE, EQ;
terminal AND, OR, LESSTAN, PLUS, MINUS, MULT;
terminal LENGTH, COMMA, NOT, TRUE, FALSE, THIS;
terminal ID, LBRACE, RBRACE, LPAREN, RPAREN;
terminal PRINT, DOT, LBRACKET, RBRACKET, SEMICOLON;
terminal Integer INT;
terminal String ID;

non terminal goal, 
non terminal main_class
non terminal class_declaration_list
non terminal class_declaration
non terminal extends
non terminal var_declaration_list
non terminal var_declaration
non terminal var_type
non terminal method_declaration_list
non terminal method_declaration
non terminal statement_list
non terminal statement
non terminal expression_list
non terminal expression

/* The grammar */
goal ::= main_class:mc class_declaration_list:cdl 
{:RESULT = Program(mc, cdl);:}
|
;

main_class ::= CLASS ID:imm LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID:strname RPAREN LBRACE statement_list:stl RBRACE RBRACE;
{:RESULT = MainClass(imm, strname, stl);:};


class_declaration_list ::= class_declaration:cd class_declaration_list:cdl
{: 
  if (cdl == null) cdl = new ClassDecList();
  cdl.addElement(cd);
  RESULT = cdl; 
:}
|
{: RESULT = new ClassDecList();:}
;
class_declaration_simple ::= CLASS ID:imm RBRACE var_declaration: vd method_declaration:md RBRACE
{:RESULT = ClassDeclSimple(imm, e, vd, md);:}
;
class_declaration_extends ::= CLASS ID:imm extends:e RBRACE var_declaration: vd method_declaration:md RBRACE
{:RESULT = ClassDeclExtends(imm, e, vd, md);:}
;
extends ::= EXTENDS ID:imm
{:RESULT = imm;:}
;

var_declaration_list ::= var_declaration:vd var_declaration_list:vdl
{:
  if (vdl == null) vdl = new VarDecList();
  vdl.addElement(vd);
  RESULT = vdl; 
  :}
|
{: RESULT = new VarDecList(); :}
;

var_declaration ::= var_type:vt ID:imm SEMICOLON 
{:RESULT = VarDecl(vt, imm);:}
;

var_type ::= BOOLEAN_TYPE 
{::}
| INT_TYPE
{::}
| INT_TYPE LBRACKET RBRACKET
{::}
| ID 
;

method_declaration_list ::= method_declaration:md method_declaration_list:mdl
{:  
  if (mdl == null) mdl = new MethodDecList();
  mdl.addElement(md);
  RESULT = mdl; 
:}
|
{: RESULT = new MethodDecList(); :}
;

method_declaration ::= PUBLIC var_type ID LPAREN paramater_list RPAREN LBRACE var_declaration_list statement_list RETURN expression SEMICOLON RBRACE
{: RESULT = MethodDecl();:}
;

paramater_list ::= paramater paramater_list 
{:
  if (vdl == null) vdl = new VarDecList();
  vdl.addElement(vd);
  RESULT = vdl; 
  :}
| 
{: RESULT = new VarDecList(); :}
;
paramater ::= var_type:vt ID:imm COMMA
{:RESULT = VarDecl(vt, imm);:}
| var_type:vt ID:imm
{:RESULT = VarDecl(vt, imm);:}
;

statement_list ::= statement:st statement_list:stl
{:
  if (stl == null) stl = new VarDecList();
  stl.addElement(st);
  RESULT = stl; 
  :}
|
{: RESULT = new StatementList(); :}
;

statement ::= LBRACE statement RBRACE
{::}
| IF LPAREN expression RPAREN statement ELSE statement
{::}
| WHILE LPAREN expression RPAREN statement
{::}
| PRINT LPAREN expression RPAREN statement
{::}
| ID EQ expression SEMICOLON
{::}
| ID LBRACKET expression RBRACKET EQ expression SEMICOLON
{::}
;

expression_list :: = expression:e expression_list:el
{: 
  if (el == null) el = new VarDecList();
  el.addElement(e);
  RESULT = el; 
:}
|
{: RESULT = new ExpressionList(); :}
;

expression ::= expression && expression
{::}
|expression ::= expression < expression
{::}
|expression ::= expression + expression
{::}
|expression ::= expression - expression
{::}
|expression ::= expression * expression
{::}
|expression LBRACKET expression RBRACKET
{::}
|expression DOT LENGTH
{::}
|expression DOT ID LPAREN expression RPAREN
{::}
|expression COMMA expression
{::}
| INT
{::}
| TRUE
{::}
| FALSE
{::}
| ID
{::}
| THIS
{::}
| NEW INT LBRACKET expression RBRACKET
{::}
| NEW ID LPAREN RPAREN
{::}
| NOT expression
{::}
| LPAREN expression RPAREN
{::}
;