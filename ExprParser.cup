import java_cup.runtime.Symbol;
import java.util.*;
import java.lang.*;
/* Preliminaries to use the scanner.  */
scan with {: 
	return lexer.next_token(); 
:};

action code {:
  public static int size = 0;
  public static Hashtable<String, Integer> labelTable 
  = new Hashtable<String, Integer>();
:}
parser code {: 

  ExprLex lexer;

  public ExprParser(ExprLex lex) {
      super(lex);
      lexer = lex;
  }
:}; 

/* Terminals (tokens returned by lexer). */
terminal CLASS, EXTENDS, PUBLIC, STATIC, VOID;
terminal STRING, NEW, RETURN, INT_TYPE;
terminal BOOLEAN_TYPE, IF, ELSE, WHILE, EQ;
terminal AND, OR, LESSTAN, PLUS, MINUS, MULT;
terminal LENGTH, COMMA, NOT, TRUE, FALSE, THIS;
terminal ID, LBRACE, RBRACE, LPAREN, RPAREN;
terminal PRINT, DOT, LBRACKET, RBRACKET, SEMICOLON;
terminal Integer INT;
terminal String ID;

non terminal goal, 
non terminal main_class
non terminal class_declaration_list
non terminal class_declaration
non terminal extends
non terminal var_declaration_list
non terminal var_declaration
non terminal var_type
non terminal method_declaration_list
non terminal method_declaration
non terminal statement_list
non terminal statement
non terminal expression_list
non terminal expression

/* The grammar */
goal ::= main_class:mc class_declaration_list:cdl 
{:RESULT = MJprogram(mc, cdl);:}
|
;

main_class ::= CLASS ID:imm LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID:strname RPAREN LBRACE statement RBRACE RBRACE;
{:RESULT = MJmain_class(imm, strname);:};


class_declaration_list ::= class_declaration:cd class_declaration_list:cdl
{:RESULT = cdc:}
|
{: RESULT = new ClassDecList();:}
;
class_declaration ::= CLASS ID:imm extends:e RBRACE var_declaration: vd method_declaration:md RBRACE
{:RESULT = MJclass(imm, e, vd, md):}
|
{::}
;
extends ::= EXTENDS ID
{:RESULT = MJprogram(mc, cdl);:}
|
{::}
;

var_declaration_list ::= var_type ID SEMICOLON var_declaration
{::}
|
{::}
;
var_declaration ::= var_type ID SEMICOLON var_declaration
{::}
|
{::}
;

var_type ::= BOOLEAN_TYPE 
{::}
| INT_TYPE
{::}
| INT_TYPE LBRACKET RBRACKET
{::}
| ID 
;

method_declaration_list ::= method_declaration method_declaration_list
{::}
|
{::}
;
method_declaration ::= PUBLIC var_type ID LPAREN paramater RPAREN LBRACE var_declaration statement RETURN expression SEMICOLON RBRACE
{::}
paramater ::= paramater 
{::}
| parameter COMMA parameter
{::}
|
{::}
;

statement_list ::= statement statement_list
{::}
|
{::}
;

statement ::= LBRACE statement RBRACE
{::}
| statement statement
{::}
| IF LPAREN expression RPAREN statement ELSE statement
{::}
| WHILE LPAREN expression RPAREN statement
{::}
| PRINT LPAREN expression RPAREN statement
{::}
| ID EQ expression SEMICOLON
{::}
| ID LBRACKET expression RBRACKET EQ expression SEMICOLON
{::}
|
{::}
;

expression_list :: = expression expression_list
{::}
|
{::}
;

expression ::= expression && expression
{::}
|expression ::= expression < expression
{::}
|expression ::= expression + expression
{::}
|expression ::= expression - expression
{::}
|expression ::= expression * expression
{::}
|expression LBRACKET expression RBRACKET
{::}
|expression DOT LENGTH
{::}
|expression DOT ID LPAREN expression RPAREN
{::}
|expression COMMA expression
{::}
| INT
{::}
| TRUE
{::}
| FALSE
{::}
| ID
{::}
| THIS
{::}
| NEW INT LBRACKET expression RBRACKET
{::}
| NEW ID LPAREN RPAREN
{::}
| NOT expression
{::}
| LPAREN expression RPAREN
{::}
|
{::}
;